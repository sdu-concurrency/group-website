{ "title" : "2014",
  "papers": [
		{
	    "bibitem": "@inproceedings{DBLP:conf/concur/CarboneMS14,  author = {Marco Carbone and  Fabrizio Montesi and  Carsten Sch{\\\"{u}}rmann},  editor = {Paolo Baldan and  Daniele Gorla},  title = {Choreographies, Logically},  booktitle = {{CONCUR} 2014 - Concurrency Theory - 25th International Conference,  {CONCUR} 2014, Rome, Italy, September 2-5, 2014. Proceedings},  series = {Lecture Notes in Computer Science},  volume = {8704},  pages = {47--62},  publisher = {Springer},  year = {2014} }",
	    "links": [
	      { "link" : "https://www.fabriziomontesi.com/files/cms14.pdf" }
	    ],
	    "tags": [ "Session Types", "Logic", "Choreographic Programming", "Process Calculi" ],
	    "authors": [ "Fabrizio Montesi" ],
	    "abstract": "In Choreographic Programming, a distributed system is programmed by giving a choreography, a global description of its interactions, instead of separately specifying the behaviour of each of its processes. Process implementations in terms of a distributed language can then be automatically projected from a choreography. We present Linear Compositional Choreographies (LCC), a proof theory for reasoning about programs that modularly combine choreographies with processes. Using LCC, we logically reconstruct a semantics and a projection procedure for programs. For the first time, we also obtain a procedure for extracting choreographies from process terms.",
			"non_group" : false,
	    "type": "conference"
	  },
		{
	    "bibitem": "@inproceedings{DBLP:conf/coordination/CarboneDM14,  author = {Marco Carbone and  Ornela Dardha and  Fabrizio Montesi},  editor = {eva K{\\\"{u}}hn and  Rosario Pugliese},  title = {Progress as Compositional Lock-Freedom},  booktitle = {Coordination Models and Languages - 16th {IFIP} {WG} 6.1 International  Conference, {COORDINATION} 2014, Held as Part of the 9th International  Federated Conferences on Distributed Computing Techniques, DisCoTec  2014, Berlin, Germany, June 3-5, 2014, Proceedings},  series = {Lecture Notes in Computer Science},  volume = {8459},  pages = {49--64},  publisher = {Springer},  year = {2014} }",
	    "links": [
	      { "link" : "https://www.fabriziomontesi.com/files/cdm14.pdf" }
	    ],
	    "tags": [ "Session Types", "Process Calculi" ],
	    "authors": [ "Fabrizio Montesi" ],
	    "abstract": "A session-based process satisfies the progress property if its sessions never get stuck when it is executed in an adequate context. Previous work studied how to define progress by introducing the notion of catalysers, execution contexts generated from the type of a process. In this paper, we refine such definition to capture a more intuitive notion of context adequacy for checking progress. Interestingly, our new catalysers lead to a novel characterisation of progress in terms of the standard notion of lock-freedom. Guided by this discovery, we also develop a conservative extension of catalysers that does not depend on types, generalising the notion of progress to untyped session-based processes. We combine our results with existing techniques for lock-freedom, obtaining a new methodology for proving progress. Our methodology captures new processes wrt previous progress analysis based on session types.",
			"non_group" : false,
	    "type": "conference"
	  },
		{
	    "bibitem": "@inproceedings{DBLP:conf/dcai/GabbrielliGM14,  author = {Maurizio Gabbrielli and  Saverio Giallorenzo and  Fabrizio Montesi},  editor = {Sigeru Omatu and  Hugues Bersini and  Juan M. Corchado Rodr{\\'{\\i}}guez and  Sara Rodr{\\'{\\i}}guez and  Pawel Pawlewski and  Edgardo Bucciarelli},  title = {Service-Oriented Architectures: From Design to Production Exploiting  Workflow Patterns},  booktitle = {Distributed Computing and Artificial Intelligence, 11th International  Conference, {DCAI} 2014, Salamanca, Spain, June 4-6, 2014},  series = {Advances in Intelligent Systems and Computing},  volume = {290},  pages = {131--139},  publisher = {Springer},  year = {2014},  url = {https://doi.org/10.1007/978-3-319-07593-8_17},  doi = {10.1007/978-3-319-07593-8_17} }",
	    "links": [
	      { "link" : "https://www.fabriziomontesi.com/files/ggm14.pdf" }
	    ],
	    "tags": [ "Jolie" ],
	    "authors": [ "Fabrizio Montesi", "Saverio Giallorenzo" ],
	    "abstract": "In Service-Oriented Architectures (SOA), services are composed by coordinating their communications into a flow of interactions. Coloured Petri nets (CPN) offer a formal yet easy tool for modelling interactions in SOAs, however mapping abstract SOAs into executable ones requires a non-trivial and time-costly analysis. Here, we propose a methodology that maps CPN-modelled SOAs into Jolie SOAs (our target language), exploiting a collection of recurring control-flow patterns, called Workflow Patterns, as composable blocks of the translation. We validate our approach with a realistic use case. In addition, we pragmatically asses the expressiveness of Jolie wrt the considered WPs.",
			"non_group" : false,
	    "type": "conference"
	  },
		{
	    "bibitem": "@incollection{DBLP:books/sp/wsf14/MontesiGZ14,  author = {Fabrizio Montesi and  Claudio Guidi and  Gianluigi Zavattaro},  editor = {Athman Bouguettaya and  Quan Z. Sheng and  Florian Daniel},  title = {Service-Oriented Programming with Jolie},  booktitle = {Web Services Foundations},  pages = {81--107},  publisher = {Springer},  year = {2014}, doi = {10.1007/978-1-4614-7518-7_4} }",
	    "links": [
	      { "link" : "https://www.fabriziomontesi.com/files/mgz14.pdf" }
	    ],
	    "tags": [ "Jolie" ],
	    "authors": [ "Fabrizio Montesi" ],
	    "abstract": "The wide adoption of service-oriented computing has led to a heterogeneous scenario formed by different technologies and specifications. Examples can be found both at the design level —the frameworks for defining services and those for defining their coordination feature fundamentally different primitives— and at the implementation level —different communication technologies are used depending on the context. In this chapter we present Jolie, a fully-fledged service-oriented programming language. Jolie addresses the aforementioned heterogeneity in two ways. On the one hand, it combines computation and composition primitives in an intuitive and concise syntax. On the other hand, the behaviour and deployment of a Jolie program are orthogonal: they can be independently defined and recombined as long as they have compatible typing",
			"non_group" : false,
	    "type": "chapter"
	  },
  {
    "bibitem": "@inproceedings{C14, author = {Cruz-Filipe, Lu{\\'i}s}, booktitle = {Foundations of Information and Knowledge Systems -- 8th International Symposium, FoIKS 2014, Bordeaux, France, March 3-7, 2014. Proceedings}, editor = {Beierle, Christoph and Meghini, Carlo}, doi = {10.1007/978-3-319-04939-7\\_18}, pages = {361--380}, publisher = {Springer}, series = {LNCS}, title = {Optimizing Computation of Repairs from Active Integrity Constraints}, volume = 8367, year = 2014}",
    "links": [{
      "link": "https://imada.sdu.dk/~lcf/pubs/paper13.pdf"
    }],
    "tags": ["Database Repair"],
    "authors": ["Luís Cruz-Filipe"],
    "abstract": "Active integrity constraints (AICs) are a form of integrity constraints for databases that not only identify inconsistencies, but also suggest how these can be overcome.  The semantics for AICs defines different types of repairs, but deciding whether an inconsistent database can be repaired and finding possible repairs is a NP- or &Sigma;<sup>p</sup><sub>2</sub>-complete problem, depending on the type of repairs one has in mind.  In this paper, we introduce two different relations on AICs: an equivalence relation of <i>independence</i>, allowing the search to be parallelized among the equivalence classes, and a <i>precedence</i> relation, inducing a stratification that allows repairs to be built progressively.  Although these relations have no impact on the worst-case scenario, they can make significant difference in the practical computation of repairs for inconsistent databases.",
    "non_group": true,
    "type": "conference"
  },
  {
    "bibitem": "@article{CLMRV14, author = {Cruz-Filipe, Lu{\\'i}s and Lanese, Ivan and Martins, Francisco and Ravara, Ant{\\'o}nio and Vasconcelos, Vasco T.}, journal = {Formal Aspects of Computing}, month = sep, doi = {10.1007/s00165-013-0284-5}, pages = {865--918}, title = {The Stream-based Service-Centered Calculus: a Foundation for Service-Oriented Programming}, volume = 26, year = 2014}",
    "links": [{
      "link": "https://imada.sdu.dk/~lcf/pubs/paper14.pdf"
    }],
    "tags": ["Process Calculi"],
    "authors": ["Luís Cruz-Filipe"],
    "abstract": "We give a formal account of SSCC, a calculus for modeling service-based systems, suitable to describe both service composition (orchestration) and the protocols that services follow when invoked (conversation). The calculus includes primitives for defining and invoking services, for isolating conversations (called sessions) among clients and servers, and for orchestrating services. The calculus is equipped with a reduction and a labeled transition semantics related by an equivalence result.<br />SSCC provides a good trade-off between expressive power for modeling and simplicity for analysis. We assess the expressive power by modeling van der Aalst workflow patterns and an automotive case study from the European project Sensoria. For analysis, we present a simple type system ensuring compatibility of client and service protocols. We also study the behavioral theory of the calculus, highlighting some axioms that capture the behavior of the different primitives.<br />As a final application of the theory, we define and prove correct some program transformations. These allow to start modeling a system from a typical UML Sequence Diagram, and then transform the specification to match the service-oriented programming style, thus simplifying its implementation using web services technology.",
    "non_group": true,
    "type": "journal"
  },
  {
    "bibitem": "@inproceedings{CCS14, author = {Codish, Michael and Cruz-Filipe, Lu{\\'i}s and Schneider-Kamp, Peter}, title = {The Quest for Optimal Sorting Networks: Efficient Generation of Two-Layer Prefixes}, pages = {359--366}, doi = {10.1109/SYNASC.2014.55}, editor = {Winkler, Franz and Negru, Viorel and Ida, Tetsuo and Jebelan, Tudor and Petcu, Dana and Watt, Stephen M. and Zaharie, Daniela}, booktitle = {16th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing, SYNASC 2014}, publisher = {IEEE}, year = 2015}",
    "links": [{
      "link": "https://imada.sdu.dk/~lcf/pubs/paper15.pdf"
    }],
    "tags": ["Sorting Networks"],
    "authors": ["Luís Cruz-Filipe"],
    "abstract": "Previous work identifying depth-optimal <i>n</i>-channel sorting networks for 9&le;<i>n</i>&le;16 is based on exploiting symmetries of the first two layers.  However, the naive generate-and-test approach typically applied does not scale. This paper revisits the problem of generating two-layer prefixes modulo symmetries. An improved notion of symmetry is provided and a novel technique based on regular languages and graph isomorphism is shown to generate the set of non-symmetric representations.  An empirical evaluation demonstrates that the new method outperforms the generate-and-test approach by orders of magnitude and easily scales until <i>n</i>=40.",
    "non_group": true,
    "type": "conference"
  },
  {
    "bibitem": "@inproceedings{CGN2014, author = {Cruz-Filipe, Lu{\\'i}s and Gaspar, Gra{\\c c}a and Nunes, Isabel}, title = {Information Flow within Relational Multi-context Systems}, pages = {97--108}, doi = {10.1007/978-3-319-13704-9\\_8}, editor = {Janowicz, Krzysztof and Schlobach, Stefan and Lambrix, Patrick and Hyv{\\\"{o}}nen, Eero}, booktitle = {Knowledge Engineering and Knowledge Management -- 19th International Conference, {EKAW} 2014, Link{\\\"{o}}ping, Sweden, November 24--28, 2014. Proceedings}, publisher = {Springer}, series = {LNAI}, volume = 8876, year = 2014}",
    "links": [{
      "link": "https://imada.sdu.dk/~lcf/pubs/paper16.pdf"
    }],
    "tags": ["Knowledge Representation"],
    "authors": ["Luís Cruz-Filipe"],
    "abstract": "Multi-context systems (MCSs) are an important framework for heterogeneous combinations of systems within the Semantic Web. In this paper, we propose generic constructions to achieve specific forms of interaction in a principled way, and sistematize some useful techniques to work with ontologies within an MCS. All these mechanisms are presented in the form of general-purpose design patterns. Their study also suggests new ways in which this framework can be further extended.",
    "non_group": true,
    "type": "conference"
  },
  {
    "bibitem": "@inproceedings{CCFS14, author = {Codish, Michael and Cruz-Filipe, Lu{\\'i}s and Frank, Michael and Schneider-Kamp, Peter}, title = {Twenty-Five Comparators is Optimal when Sorting Nine Inputs (and Twenty-Nine for Ten)}, pages = {186--193}, doi = {10.1109/ICTAI.2014.36}, booktitle = {26th {IEEE} International Conference on Tools with Artificial Intelligence, {ICTAI} 2014, Limassol, Cyprus, November 10--12, 2014}, publisher = {IEEE}, year = 2014, month = dec}",
    "links": [{
      "link": "https://imada.sdu.dk/~lcf/pubs/paper17.pdf"
    }],
    "tags": ["Sorting Networks"],
    "authors": ["Luís Cruz-Filipe"],
    "abstract": "This paper describes a computer-assisted non-existence proof of nine-input sorting networks consisting of 24 comparators, hence showing that the 25-comparator sorting network found by Floyd in 1964 is optimal. As a corollary, we obtain that the 29-comparator network found by Waksman in 1969 is optimal when sorting ten inputs.<br />This closes the two smallest open instances of the optimal size sorting network problem, which have been open since the results of Floyd and Knuth from 1966 proving optimality for sorting networks of up to eight inputs.<br />The proof involves a combination of two methodologies: one based on exploiting the abundance of symmetries in sorting networks, and the other, based on an encoding of the problem to that of satisfiability of propositional logic. We illustrate that, while each of these can single handed solve smaller instances of the problem, it is their combination which leads to an efficient solution for nine inputs.",
    "non_group": true,
    "type": "conference"
  },
  {
    "bibitem": "@article{MMP14a,  author = {Alessio Mansutti and  Marino Miculan and  Marco Peressotti},  title = {Distributed execution of bigraphical reactive systems},  journal = {{ECEASST}},  volume = {71},  year = {2014},  url = {http://journal.ub.tu-berlin.de/eceasst/article/view/994} }",
    "links": [
      { "name" : "technical report",
        "link" : "https://arxiv.org/abs/1503.02434",
        "icon" : "arxiv"}
    ],
    "abstract": "The bigraph embedding problem is crucial for many results and tools about bigraphs and bigraphical reactive systems (BRS). Current algorithms for computing bigraphical embeddings are centralized, i.e. designed to run locally with a complete view of the guest and host bigraphs. In order to deal with large bigraphs, and to parallelize reactions, we present a decentralized algorithm, which distributes both state and computation over several concurrent processes. This allows for distributed, parallel simulations where non-interfering reactions can be carried out concurrently; nevertheless, even in the worst case the complexity of this distributed algorithm is no worse than that of a centralized algorithm.",
    "tags" : [ "Concurrency", "Rewriting Systems" ],
    "authors" : [ "Marco Peressotti" ],
    "type" : "Journal",
    "non_group" : true
  },
  
  {
    "bibitem": "@inproceedings{MP14b,  author = {Marino Miculan and  Marco Peressotti},  title = {A {CSP} implementation of the bigraph embedding problem},  booktitle = {First International Workshop on Meta Models for Process Languages},  volume = {abs/1412.1042},  year = {2014} }",
    "links": [
      { "name" : "technical report",
        "link" : "https://arxiv.org/abs/1412.1042",
        "icon" : "arxiv"}
    ],
    "abstract": "A crucial problem for many results and tools about bigraphs and bigraphical reactive systems is bigraph embedding. An embedding is more informative than a bigraph matching, since it keeps track of the correspondence between the various components of the redex (guest) within the agent (host). In this paper, we present an algorithm for computing embeddings based on a reduction to a constraint satisfaction problem. This algorithm, that we prove to be sound and complete, has been successfully implemented in LibBig, a library for manipulating bigraphical reactive systems. This library can be used for implementing a wide range of tools, and it can be adapted to various extensions of bigraphs. ",
    "tags" : [ "Concurrency", "Rewriting Systems" ],
    "authors" : [ "Marco Peressotti" ],
    "type" : "Workshop",
    "non_group" : true
  },
  {
    "bibitem": "@inproceedings{MMP14b,  author = {Alessio Mansutti and  Marino Miculan and  Marco Peressotti},  editor = {Kostas Magoutis and  Peter R. Pietzuch},  title = {Multi-agent Systems Design and Prototyping with Bigraphical Reactive  Systems},  booktitle = {Distributed Applications and Interoperable Systems - 14th {IFIP} {WG}  6.1 International Conference, {DAIS} 2014, Held as Part of the 9th  International Federated Conference on Distributed Computing Techniques,  DisCoTec 2014, Berlin, Germany, June 3-5, 2014, Proceedings},  series = {Lecture Notes in Computer Science},  volume = {8460},  pages = {201--208},  publisher = {Springer},  year = {2014},  doi = {10.1007/978-3-662-43352-2\\_16} }",
    "links": [],
    "abstract": "Several frameworks and methodologies have been proposed to ease the design of Multi Agent Systems (MAS), but the vast majority of them is tightly tied to specific implementation platforms. In this paper, we outline a methodology for MAS design and prototyping in the more abstract framework of Bigraphical Reactive Systems (BRS). In our approach, components and elements of the application domain are modelled as bigraphs, and their dynamics as graph rewriting rules. Desiderata can be encoded by means of type systems or logical formulae. Then, the BDI agents (i.e., their beliefs, desires and intentions) are identified and extracted from the BRS. This yield a prototype which can be run as distributed bigraphical system, evolving by means of distributed transactional rewritings triggered by cooperating agents depending on their internal intentions and beliefs. <br/> This methodology allows the designer to benefit from the results and tools from the theory of BRS, especially in the requirement analysis and validation phases. Among other results, we mention behavioural equivalences, temporal/spatial logics, visual tools for editing, for simulation and for model checking, etc. Moreover, bigraphs can be naturally composed, thus allowing for modular design of MAS.",
    "tags" : [ "Concurrency", "Rewriting Systems"],
    "authors" : [ "Marco Peressotti" ],
    "type" : "Conference",
    "non_group" : true
  },
  {
    "bibitem": "@inproceedings{MP14,  author = {Marino Miculan and  Marco Peressotti},  editor = {Nathalie Bertrand and  Luca Bortolussi},  title = {{GSOS} for non-deterministic processes with quantitative aspects},  booktitle = {Proceedings Twelfth International Workshop on Quantitative Aspects  of Programming Languages and Systems, {QAPL} 2014, Grenoble, France,  12-13 April 2014.},  series = {{EPTCS}},  volume = {154},  pages = {17--33},  year = {2014},  url = {https://doi.org/10.4204/EPTCS.154.2},  doi = {10.4204/EPTCS.154.2} }",
    "links": [
      { "name" : "technical report",
        "link" : "https://arxiv.org/abs/1410.0893",
        "icon" : "arxiv"}
    ],
    "abstract": "General frameworks have been recently proposed as unifying theories for processes combining non-determinism with quantitative aspects (such as probabilistic or stochastically timed executions), aiming to provide general results and tools. This paper provides two contributions in this respect. First, we present a general GSOS specification format and a corresponding notion of bisimulation for non-deterministic processes with quantitative aspects. These specifications define labelled transition systems according to the ULTraS model, an extension of the usual LTSs where the transition relation associates any source state and transition label with state reachability weight functions (like, e.g., probability distributions). This format, hence called Weight Function GSOS (WF-GSOS), covers many known systems and their bisimulations (e.g. PEPA, TIPP, PCSP) and GSOS formats (e.g. GSOS, Weighted GSOS, Segala-GSOS, among others). The second contribution is a characterization of these systems as coalgebras of a class of functors, parametric on the weight structure. This result allows us to prove soundness and completeness of the WF-GSOS specification format, and that bisimilarities induced by these specifications are always congruences.",
    "tags" : [ "Concurrency", "Coalgebras", "Quantitative Semantics", "Behavioural Theory" ],
    "authors" : [ "Marco Peressotti" ],
    "type" : "Workshop",
    "non_group" : true
  },
  {
    "bibitem": "@inproceedings{PGLMG14,  author = {Mila Dalla Preda and  Saverio Giallorenzo and  Ivan Lanese and  Jacopo Mauro and  Maurizio Gabbrielli},  title = {{AIOCJ:} {A} Choreographic Framework for Safe Adaptive Distributed  Applications},  booktitle = {Software Language Engineering - 7th International Conference, {SLE}  2014, V{\\\"{a}}ster{\\aa}s, Sweden, September 15-16, 2014. Proceedings},  pages = {161--170},  year = {2014},  crossref = {DBLP:conf/sle/2014},  url = {https://doi.org/10.1007/978-3-319-11245-9_9},  doi = {10.1007/978-3-319-11245-9_9},  timestamp = {Tue, 23 May 2017 01:10:43 +0200},  biburl = {https://dblp.org/rec/bib/conf/sle/PredaGLMG14},  publisher = {Springer}, bibsource = {dblp computer science bibliography, https://dblp.org} }",
    "links": [
      { "link" : "http://www.saveriogiallorenzo.com/publications/aiocj/" },
      { "name" : "website", "icon" : "site", "link" : "http://www.cs.unibo.it/projects/jolie/aiocj.html" }
    ],
    "abstract": "We present AIOCJ, a framework for programming distributed adaptive applications. Applications are programmed using AIOC, a choreographic language suited for expressing patterns of interaction from a global point of view. AIOC allows the programmer to specify which parts of the application can be adapted. Adaptation takes place at runtime by means of rules, which can change during the execution to tackle possibly unforeseen adaptation needs. AIOCJ relies on a solid theory that ensures applications to be deadlock-free by construction also after adaptation. We describe the architecture of AIOCJ, the design of the AIOC language, and an empirical validation of the framework.",
    "tags" : [ "Choreographic Programming", "Adaptation" ],
    "authors" : [ "Saverio Giallorenzo", "Jacopo Mauro" ],
    "type" : "Conference",
    "non_group" : true
  }
]
}
